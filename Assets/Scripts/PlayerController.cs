using System;using System.Collections;using UnityEngine;using UnityEngine.UI;[RequireComponent(typeof(CharacterController))]public class PlayerController : MonoBehaviour{    public Image staminaBarUi;    public float walkingSpeed = 3.5f;    public float runningSpeed = 7f;    public float jumpSpeed = 8.0f;    public float gravity = 20.0f;    public Camera playerCamera;    public float lookSpeed = 2.0f;    public float lookXLimit = 45.0f;    public float staminaSeconds = 5f;    public float maxStaminaSeconds = 5f;    public float staminaSecondsRechargeLag = 3f;    private bool _wasRunning = false;    private bool _rechargeStaminaCoroutineRunning = true;    private Camera _playerCamera;    private Walking _walking;    CharacterController _characterController;    Vector3 _moveDirection = Vector3.zero;    float _rotationX = 0;    private bool _wasWalking;    private float _lastPosition;    private bool _shouldReset;    private bool _playerExhausted;    [HideInInspector] public bool canMove = true;    private void Awake()    {        _walking = GetComponentInChildren<Walking>();        _playerCamera = Camera.main;    }    void Start()    {        _characterController = GetComponent<CharacterController>();        staminaBarUi.type = Image.Type.Filled;        staminaBarUi.fillMethod = Image.FillMethod.Horizontal;        staminaBarUi.fillAmount = 1;        // Lock cursor        Cursor.lockState = CursorLockMode.Locked;        Cursor.visible = false;    }    void Update()    {        // We are grounded, so recalculate move direction based on axes        var forward = transform.TransformDirection(Vector3.forward);        var right = transform.TransformDirection(Vector3.right);        // Press Left Shift to run        var isRunning = Input.GetKey(KeyCode.LeftShift);        ReduceStamina(isRunning, _wasRunning);        var curSpeedX = canMove            ? (isRunning && HasStamina() ? runningSpeed : walkingSpeed) * Input.GetAxis("Vertical")            : 0;        var curSpeedY = canMove            ? (isRunning && HasStamina() ? runningSpeed : walkingSpeed) * Input.GetAxis("Horizontal")            : 0;        var movementDirectionY = _moveDirection.y;        _moveDirection = forward * curSpeedX + right * curSpeedY;        HeadBobLogic(_characterController.isGrounded && (Math.Abs(curSpeedX) > 0 || Math.Abs(curSpeedY) > 0),            isRunning);        // if (Input.GetButton("Jump") && canMove && _characterController.isGrounded)        // {        //     _moveDirection.y = jumpSpeed;        // }        // else        // {        //     _moveDirection.y = movementDirectionY;        // }        // Apply gravity. Gravity is multiplied by deltaTime twice (once here, and once below        // when the moveDirection is multiplied by deltaTime). This is because gravity should be applied        // as an acceleration (ms^-2)        if (!_characterController.isGrounded)        {            _moveDirection.y -= gravity * Time.deltaTime;        }        // Move the controller        _characterController.Move(_moveDirection * Time.deltaTime);        // Player and Camera rotation        if (canMove)        {            _rotationX += -Input.GetAxis("Mouse Y") * lookSpeed;            _rotationX = Mathf.Clamp(_rotationX, -lookXLimit, lookXLimit);            playerCamera.transform.localRotation = Quaternion.Euler(_rotationX, 0, 0);            transform.rotation *= Quaternion.Euler(0, Input.GetAxis("Mouse X") * lookSpeed, 0);        }        _wasRunning = isRunning;        DoorsLogic();        _lastPosition = _playerCamera.transform.rotation.eulerAngles.y;    }    private void HeadBobLogic(bool isWalking, bool isRunning)    {        if (isWalking && !_wasWalking) _walking.Walk();        if (!isWalking && _wasWalking) _walking.StopWalk();        _walking.Run(isRunning);        _wasWalking = isWalking;    }    private void DoorsLogic()    {        if (!Input.GetMouseButton(0))        {            _shouldReset = true;            return;        }        if (_shouldReset)        {            _lastPosition = _playerCamera.transform.rotation.eulerAngles.y;            _shouldReset = false;            return;        }        if (!Physics.Raycast(_playerCamera.transform.position, _playerCamera.transform.forward, out var hit,            2f)) return;        if (!hit.transform.CompareTag("Doot")) return;        var diff = _playerCamera.transform.rotation.eulerAngles.y - _lastPosition;        hit.transform.Rotate(Vector3.up, diff, Space.World);    }    private void ReduceStamina(bool isRunning, bool wasRunning)    {        if (isRunning && wasRunning && staminaSeconds > 0)        {            // stop recharging if running            if (_rechargeStaminaCoroutineRunning)            {                StopAllCoroutines();                _rechargeStaminaCoroutineRunning = false;            }            // reduce stamina            UpdateStamina(-Time.deltaTime);            if (staminaSeconds <= 0)            {                SetPlayerExhausted();            }        }        if (!isRunning && !wasRunning && !_rechargeStaminaCoroutineRunning)        {            StartCoroutine(RechargeStaminaCoroutine());        }    }    private void SetPlayerExhausted()    {        staminaSeconds = 0;        _playerExhausted = true;        walkingSpeed /= 2; // exhausted    }    private void SetPlayerNotExhausted()    {        if (_playerExhausted)        {            _playerExhausted = false;            walkingSpeed *= 2;        }    }    private IEnumerator RechargeStaminaCoroutine()    {        _rechargeStaminaCoroutineRunning = true;        yield return new WaitForSeconds(staminaSecondsRechargeLag);        while (staminaSeconds != maxStaminaSeconds)        {            yield return new WaitForSeconds(0.2f);            UpdateStamina(0.1f);            if (staminaSeconds > maxStaminaSeconds)            {                staminaSeconds = maxStaminaSeconds;            }        }        SetPlayerNotExhausted();        _rechargeStaminaCoroutineRunning = false;    }    private bool HasStamina() => staminaSeconds > 0;    private void UpdateStamina(float amount)    {        staminaSeconds += amount;        staminaBarUi.fillAmount = staminaSeconds / maxStaminaSeconds;    }}