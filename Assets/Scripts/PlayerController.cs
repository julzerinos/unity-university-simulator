using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;[RequireComponent(typeof(CharacterController))]public class PlayerController : MonoBehaviour{    public Image staminaBarUI;    public float walkingSpeed = 3.5f;    public float runningSpeed = 7f;    public float jumpSpeed = 8.0f;    public float gravity = 20.0f;    public Camera playerCamera;    public float lookSpeed = 2.0f;    public float lookXLimit = 45.0f;    public float staminaSeconds = 5f;    public float maxStaminaSeconds = 5f;    public float staminaSecondsRechargeLag = 3f;    private bool _wasRunning = false;    private bool _rechargeStaminaCoroutineRunning = true;    private Camera _playerCamera;    private AudioSource _breathingAudioSource;    CharacterController characterController;    Vector3 moveDirection = Vector3.zero;    float rotationX = 0;    [HideInInspector] public bool canMove = true;    private void Awake()    {        _playerCamera = Camera.main;        _breathingAudioSource = GetComponent<AudioSource>();    }    void Start()    {        characterController = GetComponent<CharacterController>();        staminaBarUI.type = Image.Type.Filled;        staminaBarUI.fillMethod = Image.FillMethod.Horizontal;        staminaBarUI.fillAmount = 1;        // Lock cursor        Cursor.lockState = CursorLockMode.Locked;        Cursor.visible = false;    }    void Update()    {        // We are grounded, so recalculate move direction based on axes        Vector3 forward = transform.TransformDirection(Vector3.forward);        Vector3 right = transform.TransformDirection(Vector3.right);        // Press Left Shift to run        bool isRunning = Input.GetKey(KeyCode.LeftShift);        reduceStamina(isRunning, _wasRunning);        float curSpeedX = canMove            ? (isRunning && HasStamina() ? runningSpeed : walkingSpeed) * Input.GetAxis("Vertical")            : 0;        float curSpeedY = canMove            ? (isRunning && HasStamina() ? runningSpeed : walkingSpeed) * Input.GetAxis("Horizontal")            : 0;        float movementDirectionY = moveDirection.y;        moveDirection = (forward * curSpeedX) + (right * curSpeedY);        if (Input.GetButton("Jump") && canMove && characterController.isGrounded)        {            moveDirection.y = jumpSpeed;        }        else        {            moveDirection.y = movementDirectionY;        }        // Apply gravity. Gravity is multiplied by deltaTime twice (once here, and once below        // when the moveDirection is multiplied by deltaTime). This is because gravity should be applied        // as an acceleration (ms^-2)        if (!characterController.isGrounded)        {            moveDirection.y -= gravity * Time.deltaTime;        }        // Move the controller        characterController.Move(moveDirection * Time.deltaTime);        // Player and Camera rotation        if (canMove)        {            rotationX += -Input.GetAxis("Mouse Y") * lookSpeed;            rotationX = Mathf.Clamp(rotationX, -lookXLimit, lookXLimit);            playerCamera.transform.localRotation = Quaternion.Euler(rotationX, 0, 0);            transform.rotation *= Quaternion.Euler(0, Input.GetAxis("Mouse X") * lookSpeed, 0);        }        _wasRunning = isRunning;        DoorsLogic();                _lastPosition = _playerCamera.transform.rotation.eulerAngles.y;    }    private float _lastPosition;    private bool _shouldReset;    private bool _playerExhausted = false;    private void DoorsLogic()    {        if (!Input.GetMouseButton(0))        {            _shouldReset = true;            return;        }        if (_shouldReset)        {            _lastPosition = _playerCamera.transform.rotation.eulerAngles.y;            _shouldReset = false;            return;        }        if (!Physics.Raycast(_playerCamera.transform.position, _playerCamera.transform.forward, out var hit,            2f)) return;        if (!hit.transform.CompareTag("Doot")) return;        var diff = _playerCamera.transform.rotation.eulerAngles.y - _lastPosition;        hit.transform.Rotate(Vector3.up, diff, Space.World);    }    private void reduceStamina(bool isRunning, bool wasRunning)    {        if (isRunning && wasRunning && staminaSeconds > 0)        {            // stop recharging if running            if (_rechargeStaminaCoroutineRunning)            {                StopAllCoroutines();                _rechargeStaminaCoroutineRunning = false;            }            // reduce stamina            UpdateStamina(-Time.deltaTime);            if (staminaSeconds <= 0)            {                SetPlayerExhausted();            }        }        if (!isRunning && !wasRunning && !_rechargeStaminaCoroutineRunning)        {            StartCoroutine(RechargeStaminaCoroutine());        }    }    private void SetPlayerExhausted()    {        _breathingAudioSource.Play();        staminaSeconds = 0;        _playerExhausted = true;        walkingSpeed /= 2; // exhausted    }    private void SetPlayerNotExhausted()    {        if (_playerExhausted)        {            _breathingAudioSource.Stop();            _playerExhausted = false;            walkingSpeed *= 2;        }    }    private IEnumerator RechargeStaminaCoroutine()    {        _rechargeStaminaCoroutineRunning = true;        yield return new WaitForSeconds(staminaSecondsRechargeLag);        while (staminaSeconds != maxStaminaSeconds)        {            yield return new WaitForSeconds(0.2f);            UpdateStamina(0.1f);            if (staminaSeconds > maxStaminaSeconds)            {                staminaSeconds = maxStaminaSeconds;            }        }        SetPlayerNotExhausted();        _rechargeStaminaCoroutineRunning = false;    }    private bool HasStamina() => staminaSeconds > 0;    private void UpdateStamina(float amount)    {        staminaSeconds += amount;        staminaBarUI.fillAmount = staminaSeconds / maxStaminaSeconds;    }}