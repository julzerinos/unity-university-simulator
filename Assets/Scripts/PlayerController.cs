using System;using System.Collections;using System.Collections.Generic;using Rooms;using UnityEngine;using UnityEngine.SceneManagement;using UnityEngine.UI;[RequireComponent(typeof(CharacterController))]public class PlayerController : MonoBehaviour{    public Image staminaBarUi;    public float walkingSpeed = 3.5f;    public float runningSpeed = 7f;    public float jumpSpeed = 8.0f;    public float gravity = 20.0f;    public Camera playerCamera;    public float lookSpeed = 2.0f;    public float lookXLimit = 45.0f;    public float staminaSeconds = 5f;    public float maxStaminaSeconds = 5f;    public float staminaSecondsRechargeLag = 3f;    private bool _wasWalking;    private bool _wasRunning = false;    private bool _rechargeStaminaCoroutineRunning = true;    private bool _calculatorHidden = true;    private Walking _walking;    private Camera _playerCamera;    private AudioSource _breathingAudioSource;    private CharacterController _characterController;    private Vector3 _moveDirection = Vector3.zero;    private float _rotationX = 0;    private GameObject _calculatorRotator;    private Light _flashlight;    [HideInInspector] public bool canMove = true;    private void Awake()    {        _walking = GetComponentInChildren<Walking>();        _playerCamera = Camera.main;        _breathingAudioSource = GetComponent<AudioSource>();        _calculatorRotator = transform.Find("Main Camera").Find("CalculatorRotator").gameObject;        _flashlight = transform.Find("Main Camera").Find("Spot Light").GetComponent<Light>();        StartCoroutine(FadeFromBlackCoroutine());    }    private void Start()    {        _characterController = GetComponent<CharacterController>();        staminaBarUi.type = Image.Type.Filled;        staminaBarUi.fillMethod = Image.FillMethod.Horizontal;        staminaBarUi.fillAmount = 1;        // Lock cursor        Cursor.lockState = CursorLockMode.Locked;        Cursor.visible = false;    }    private void Update()    {        if (_isPlayerDead)            return;        // We are grounded, so recalculate move direction based on axes        var forward = transform.TransformDirection(Vector3.forward);        var right = transform.TransformDirection(Vector3.right);        // Press Left Shift to run        var isRunning = Input.GetKey(KeyCode.LeftShift);        ReduceStamina(isRunning, _wasRunning);        var curSpeedX = canMove            ? (isRunning && HasStamina() ? runningSpeed : walkingSpeed) * Input.GetAxis("Vertical")            : 0;        var curSpeedY = canMove            ? (isRunning && HasStamina() ? runningSpeed : walkingSpeed) * Input.GetAxis("Horizontal")            : 0;        var movementDirectionY = _moveDirection.y;        _moveDirection = (forward * curSpeedX) + (right * curSpeedY);        HeadBobLogic(            _characterController.isGrounded && (Math.Abs(curSpeedX) > 0 || Math.Abs(curSpeedY) > 0),            isRunning && staminaSeconds > 0        );        // if (Input.GetButton("Jump") && canMove && characterController.isGrounded) // TODO: fix jumping in bobbing animator        // {        //     moveDirection.y = jumpSpeed;        // }        // else        {            _moveDirection.y = movementDirectionY;        }        // Apply gravity. Gravity is multiplied by deltaTime twice (once here, and once below        // when the moveDirection is multiplied by deltaTime). This is because gravity should be applied        // as an acceleration (ms^-2)        if (!_characterController.isGrounded)        {            _moveDirection.y -= gravity * Time.deltaTime;        }        // Move the controller        _characterController.Move(_moveDirection * Time.deltaTime);        // Player and Camera rotation        if (canMove)        {            _rotationX += -Input.GetAxis("Mouse Y") * lookSpeed;            _rotationX = Mathf.Clamp(_rotationX, -lookXLimit, lookXLimit);            playerCamera.transform.localRotation = Quaternion.Euler(_rotationX, 0, 0);            transform.rotation *= Quaternion.Euler(0, Input.GetAxis("Mouse X") * lookSpeed, 0);        }        if (Input.GetKeyDown("c"))        {            if (!_rotateCalculatorCoroutineRunning)            {                StartCoroutine(RotateCalculatorCoroutine());            }        }        if (Input.GetKeyDown("f"))        {            _flashlight.enabled = !_flashlight.enabled;        }        _wasRunning = isRunning;        DoorsLogic();        _lastPosition = _playerCamera.transform.rotation.eulerAngles.y;    }    private float _lastPosition;    private bool _shouldReset;    private bool _playerExhausted = false;    private bool _rotateCalculatorCoroutineRunning = false;    private bool _passOutCoroutineRunning = false;    private bool _isPlayerDead = false;    private void HeadBobLogic(bool isWalking, bool isRunning)    {        if (isWalking && !_wasWalking) _walking.Walk();        if (!isWalking && _wasWalking) _walking.StopWalk();        _walking.Run(isRunning);        _wasWalking = isWalking;    }    private void DoorsLogic()    {        if (!Input.GetMouseButton(0))        {            _shouldReset = true;            return;        }        if (_shouldReset)        {            _lastPosition = _playerCamera.transform.rotation.eulerAngles.y;            _shouldReset = false;            return;        }        if (!Physics.Raycast(_playerCamera.transform.position, _playerCamera.transform.forward, out var hit,                2f)) return;        if (!hit.transform.CompareTag("Doot")) return;        var door = hit.collider.gameObject.GetComponent<Door>();        var diff = _playerCamera.transform.rotation.eulerAngles.y - _lastPosition;        door.RotateDoor(diff, transform.forward);        _lastPosition = _playerCamera.transform.rotation.eulerAngles.y;    }    private void ReduceStamina(bool isRunning, bool wasRunning)    {        if (isRunning && wasRunning && staminaSeconds > 0)        {            // stop recharging if running            if (_rechargeStaminaCoroutineRunning)            {                StopAllCoroutines();                _rechargeStaminaCoroutineRunning = false;            }            // reduce stamina            UpdateStamina(-Time.deltaTime);            if (staminaSeconds <= 0)            {                SetPlayerExhausted();            }        }        if (!isRunning && !wasRunning && !_rechargeStaminaCoroutineRunning)        {            StartCoroutine(RechargeStaminaCoroutine());        }    }    private void SetPlayerExhausted()    {        _breathingAudioSource.Play();        staminaSeconds = 0;        _playerExhausted = true;        walkingSpeed /= 2; // exhausted    }    private void SetPlayerNotExhausted()    {        if (_playerExhausted)        {            _breathingAudioSource.Stop();            _playerExhausted = false;            walkingSpeed *= 2;        }    }    private IEnumerator RechargeStaminaCoroutine()    {        _rechargeStaminaCoroutineRunning = true;        yield return new WaitForSeconds(staminaSecondsRechargeLag);        while (staminaSeconds != maxStaminaSeconds)        {            yield return new WaitForSeconds(0.2f);            UpdateStamina(0.1f);            if (staminaSeconds > maxStaminaSeconds)            {                staminaSeconds = maxStaminaSeconds;            }        }        SetPlayerNotExhausted();        _rechargeStaminaCoroutineRunning = false;    }    private bool HasStamina() => staminaSeconds > 0;    private void UpdateStamina(float amount)    {        staminaSeconds += amount;        staminaBarUi.fillAmount = staminaSeconds / maxStaminaSeconds;    }    private IEnumerator RotateCalculatorCoroutine()    {        _rotateCalculatorCoroutineRunning = true;        var addedAngle = 0;        while (addedAngle < 45)        {            yield return new WaitForEndOfFrame();            if (_calculatorHidden)            {                _calculatorRotator.transform.Rotate(Vector3.right, -1);            }            else            {                _calculatorRotator.transform.Rotate(Vector3.right, 1);            }            addedAngle += 1;        }        _calculatorHidden = !_calculatorHidden;        _rotateCalculatorCoroutineRunning = false;    }    public void PassOut()    {        if (!_passOutCoroutineRunning)        {            StartCoroutine(PassOutCoroutine());        }    }    private IEnumerator PassOutCoroutine()    {        _passOutCoroutineRunning = true;        _calculatorRotator.SetActive(false);        transform.Find("Canvas").gameObject.SetActive(false);        _isPlayerDead = true;        while (RenderSettings.fogDensity < 1)        {            yield return new WaitForEndOfFrame();            RenderSettings.fogDensity += 0.01f;        }        _passOutCoroutineRunning = false;        yield return new WaitForSeconds(1);        var currentScene = SceneManager.GetActiveScene();        SceneManager.LoadScene(currentScene.name);    }    private IEnumerator FadeFromBlackCoroutine()    {        var target = RenderSettings.fogDensity;        RenderSettings.fogDensity = 1;        while (RenderSettings.fogDensity > target)        {            yield return new WaitForEndOfFrame();            RenderSettings.fogDensity -= 0.01f;        }    }}